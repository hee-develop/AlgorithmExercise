## 1로 만들기

문제 링크 : https://www.acmicpc.net/problem/1463

DP문제.
2, 3은 1회만에 1이 된다.
4는 2로 나누면 2회만에 1이 된다.
5는 2나 3으로 나눌 수 없으므로 1을 뺀다. 4는 2로 나누면 2회만에 1이 되므로, 총합 3회가 된다.
6은 3으로 나누면 2가 되고, 2는 1회만에 1이 된다. 즉 총합 2회가 된다.
7은 2나 3으로 나눌 수 없으므로 1을 뺀다. 6은 총합 2회이므로 총합 3회가 된다.

위 규칙을 잘 살펴보면 다음과 같다.

1. 3으로 나눌 수 있는 값은, 3으로 나눠진 수의 최소 연산 횟수 + 1과 같다
2. 2로 나눌 수 있는 값은, 2로 나눠진 수의 최소 연산 횟수 + 1과 같다
3. 2, 3으로 나눌 수 없는 값은, 이전 값의 최소 연산 횟수 + 1과 같다

그리고 중요한 건 같은 숫자라도 1, 2, 3의 연산으로 만들어진 결과는 다르므로, 이 중 최솟값이 실제 최솟값이 된다.
예를 들어, 10은 `10 -> 5 -> 4 -> 2 -> 1`로 연산하면 4회지만, `10 -> 9 -> 3 -> 1`로 연산하면 3회만에 1이 된다.
`Math.min`을 활용해 연산 1, 2, 3 중 최솟값을 도출하면 풀 수 있다.

```js
const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().split(' ');

const n = parseInt(input[0]);

const arr = [...Array(n)].map(() => 0); // [0, 0, 0, ...]

for (let i = 2; i <= n; i++) {
  arr[i] = arr[i-1] + 1;

  if (i % 2 === 0) {
    arr[i] = Math.min(arr[i], arr[i/2] + 1);
  }
  if (i % 3 === 0) {
    arr[i] = Math.min(arr[i], arr[i/3] + 1);
  }
}

console.log(arr[arr.length-1]);
```
